---
{"dg-publish":true,"permalink":"/laboratornaya-rabota-3-nachalo-raboty-s-app-armor/","dgShowFileTree":true}
---


---
#  2022-ФГиИБ-ИБ-1б Некрасова Валерия 
---


### [Apparmor в Ubuntu](https://help.ubuntu.ru/wiki/%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D0%BE_ubuntu_server/%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C/apparmor)

Существует 2 режима работы AppArmor:

- enforce;
- complain.

Для настройки режимов используется ряд утилит, которые необходимо установить:

```
sudo apt install apparmor-utils
```

В режиме `enforce` система **AppArmor** будет ограничивать работу приложения согласно профилю и сообщать о попытках нарушения установленных правил, а в режиме `complain` – только сообщать о нарушениях правил, позволяя приложению выполнять любые запрашиваемые действия.

**AppArmor** устанавливается и загружается по умолчанию. Он использует профили приложений для определения какие файлы и права доступа требуются приложению. Некоторые пакеты устанавливают свои собственные профили, а дополнительные профили можно найти в пакете `apparmor-profiles`.

```
sudo apt install apparmor-profiles
```

После утановки профилей, появляются новые записи в выводе команды `apparmor_status`.

Для того, чтобы начать контролировать приложение с помощью `AppArmor`, необходимо поместить профиль приложения в директорию `/etc/apparmor.d/`:

```
cp /path/to/usr.bin.app /etc/apparmor.d/
```

Больше профилей доступно в директории `/usr/share/apparmor/extra-profiles/`

После чего приложение можно перезапустить:

```
kill -9 $APP_PID; /usr/sbin/app
```

Логгирование производится в файл: `/var/log/syslog`.

Вывести всю информацию по **AppArmor** можно с помощью следующей команды:

```
sudo cat /var/log/syslog | grep apparmor
```

Содержимое файла `/etc/apparmor.d/bin.ping`:

```
#include <tunables/global>
profile ping /{usr/,}bin/{,iputils-}ping flags=(complain) {
  #include <abstractions/base>
  #include <abstractions/consoles>
  #include <abstractions/nameservice>

  capability net_raw,
  capability setuid,
  network inet raw,
  network inet6 raw,

  /{,usr/}bin/{,iputils-}ping mixr,
  /etc/modules.conf r,

  # Site-specific additions and overrides. See local/README for details.
  #include <local/bin.ping>
}
```

Все достаточно понятно, кроме флагов mixr. Описание значений флагов ниже:

- r — чтение;
- w — запись
- a — инкрементальная запись в конец файла, от английского append;
- k — блокировка файлов;
- l — создание символических ссылок на исполняемые файлы;
- m — загрузка исполняемых файлов в память;
- cx — переход в профиль нижнего уровня при выполнении;
- Cx — переход в профиль нижнего уровня при выполнении с очисткой переменных окружения;
- ix — наследование исполнения;
- px — требуется определение дискретного профиля безопасности для ресурса;
- Px — требуется определение дискретного профиля безопасности для ресурса, производится очистка переменных окружения;
- ux — не проверять запуск новых процессов;
- Ux — не проверять запуск новых процессов и производить очистку переменных окружения;

### 1. Проверка complain и enforce_режимов
**1.1. Создайте копию утилиты `ping` (из директории `/bin/`), а вместо нее скопируйте утилиту `cp` (`/bin/cp -> /bin/ping`). После этого переведите профиль `bin.ping` в режим `enforce`. Создайте в домашней директории файл и попробуйте его скопировать с помощью утилиты `ping` (которая, по факту, является копией утилиты `cp`).**

Первым делом создаем копию и копируем утильту с помощью команд  `cp /bin/ping /bin/my_ping` и `cp /bin/cp /bin/ping`. Далее переведем профиль с режим enforce  `aa-enforce /etc/apparmor .d/bin.ping`. Теперь создаем файл(я создала 2) и пробуем скопировать.
![Снимок экрана (79).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(79).png)
Объясните, что произошло. Посмотрите журнал, что там за сообщения (относительно этой операции), что они значат?
Мы получили сообщение ping: не удалось выполнить. Отказано в доступе. Причиной этому служит то, что ,согласно профилю ping, нет прав для вызова для файла. Ну и запрашиваемая маска r и отклоненная маска r.

**1.2. Переведите профиль `bin.ping` в режим `complain`. Повторите действия из шага 1.1. Что изменилось? Объясните. Какие теперь записи в журнале?**

Переведем профиль в режим complain с помощью `aa-complain /etc/apparmor.d/bin.ping ` и повторяем шаги из этапа 1.1.
![Снимок экрана (80).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(80).png)
Теперь у нас AppArmor позволяет совершать действия с файлами.

**1.3. Верните утилиту `ping` на свое место.**

С помощью `cp /bin/my_ping /bin/ping` возвращаем все на свое место.
![Снимок экрана (81).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(81).png)

**1.4. Переведите профиль `bin.ping` в режим `enforce`. Попробуйте воспользоваться утилитов (из шага 1.1.) `my_ping`.**

Переводим профиль с помощью `aa-enforce/etc/apparmor.d/bin.ping`
![Снимок экрана (82).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(82).png)
Объясните, что произошло. Посмотрите журнал, что там за сообщения (относительно этой операции)?
Скринов у меня из журнала нет(я забыла их сделать). Все работает нормально, --ping работает в штатном режиме, как до всех взаимодействий. Кроме смены режима в журнале ничего нет.


### 2. AppArmor на примере Docker
**2.1. Установите Docker**

Докер у меня был установлен ещё давно, но на всякий случай проверим.
![Снимок экрана (83).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(83).png)
Да всё есть, все работает.
Создайте группу `docker`, добавьте в нее своего пользователя. При необходимости перезагрузите систему.
Создаем пользователя.
![Снимок экрана (84).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(84).png)
Создаем группу
![Снимок экрана (85).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(85).png)
Добавляем туда пользователя
![Снимок экрана (86).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(86).png)

**2.2. Создайте Docker-конетейнер с ubuntu:**

```
docker container run --rm -it --cap-add SYS_ADMIN --security-opt seccomp=unconfined ubuntu sh
```
![Снимок экрана (87).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(87).png)
Что значат ключи: - `--cap-add` - `seccomp=unconfined`
1. Ключ --cap-add используется для добавления возможностей (capabilities) к контейнеру Docker. В данном случае добавляется возможность SYS_ADMIN, которая предоставляет привилегии для выполнения системных операций, таких как управление процессами и устройствами. seccomp=unconfinedю
2. Ключ --seccomp=unconfined используется для настройки политики безопасности Seccomp. Seccomp - это механизм безопасности, который позволяет ограничить выполнение системных вызовов внутри контейнера. По умолчанию Docker использует строгое ограничение, которое запрещает большинство системных вызовов. Установка seccomp=unconfined отключает эти ограничения, позволяя выполнять любые системные вызовы, что может быть полезно для некоторых специфических задач, но также увеличивает риск безопасности.

Создайте два новых каталога (внутри контейнера), смонтируйте первый каталог в другой каталог (подробнее, `mount --bind`)
Создаем новые каталоги.
![Снимок экрана (87) 1.png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(87)%201.png)


### 3. Пользовательский профиль AppArmor
**3.1. Скачайте материалы для ЛР из репозитория Docker:**

```
git clone https://github.com/docker/labs.git
cd labs/security/apparmor/wordpress
```

Вводим команды, которые представлены выше и скачиваем материалы для ЛР. С помощью второй команды переходим в папку с материалами.
![Снимок экрана (88).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(88).png)

**3.2. Опишите, какие контейнеры предлагается создать (docker-compose.yml). Создайте контейнеры с помощью docker-compose**

Посмотрим, что содержится внутри с помощью команды `cat docker-compose.yml`.
![Снимок экрана (89).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(89).png)
Предлагается создать:
1) WordPress 
2) MySQL(образ mariadb)
Пробуем запустить контейнер с помощью `docker-compose up`.
![Снимок экрана (90).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(90).png)
Ничего не получилось, появились ошибки. С помощью команды `nano` залезаем внутрь и немного исправляем файлик.
![Снимок экрана (112).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(112).png)
Теперь ещё раз попробуем запустить.
![Снимок экрана (91).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(91).png)
Все получилось.

**3.3. Проверьте работоспособность WordPress, выбрав язык и установив какие-либо плагины.**

![Снимок экрана (93).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(93).png)
![Снимок экрана (94).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(94).png)
Все ли работает?
Да, все работает, только я это не заскринила. Язык изменить можно, только русский найти у меня не получилось.

**3.4. Удалите созданные контейнеры.**

Удаляем контейнеры.
![Снимок экрана (95).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(95).png)

**3.5. Добавьте wparmor профиль в файл конфигурации.**

Вставьте:

```
security_opt:
    - apparmor=wparmor
```

Указываем в `docker-compose.yml` профиль `wparmor`. `wparmor` выглядит следующим образом:
![Снимок экрана (96).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(96).png)
Опишите правила в `wparmor`.
- `#include <tunables/global>` - включаем глобальные переменные;
- `profile wparmor flags=(attach_disconnected,mediate_deleted)` - данные профили остаются активными даже после потери соединения с файловой системой, при этом контроль доступа продолжается даже для удалённых файлов;
- `#include <abstractions/base>` - импортируем базовый профиль;
- `deny @{PROC}/* w,` - в данном случае, `{PROC}` является абстракцией, определенной посредством `<abstractions/base>`. В данном случае, она эквивалентна `/proc/`. То есть, эта строка предотвращает изменение файлов, расположенных прямо в `/proc`, но не затрагивает подкаталоги.
- `deny @{PROC}/{[^1-9],[^1-9][^0-9],[^1-9s][^0-9y][^0-9s],[^1-9][^0-9][^0-9][^0-9]*}/** w,` - запрещает запись в файлы и подкаталоги внутри `/proc`, за исключением тех, чьи имена состоят исключительно из цифр (т.е. идентификаторов процессов или же PID) или начинаются с "syslog", таким образом предотвращая изменение системных файлов в `/proc`, сохраняя возможность доступа к информации о процессах и системному журналу;
- `deny @{PROC}/sys/[^k]** w,` - запрещает запись во все подкаталоги внутри `/proc/sys/`, кроме тех, которые начинаются с буквы "k" (например, `/proc/sys/kernel`);
- `deny @{PROC}/sys/kernel/{?,??,[^s][^h][^m]**} w,` - запрещает запись в файлы и подкаталоги внутри `/proc/sys/kernel/`, за исключением тех, чьи имена начинаются с "shm" (например, `shmall`, `shmmax`);
- `deny @{PROC}/sysrq-trigger rwklx,` - полностью запрещает любые операции (чтение, запись, выполнение, блокировка) с файлом `/proc/sysrq-trigger`, который отвечает за отправку команд аварийного восстановления системе;
- `deny @{PROC}/mem rwklx,` - запрет предотвращает чтение или модификацию содержимого оперативной памяти, обеспечивая безопасность системы;
- `deny @{PROC}/kmem rwklx,` - предотвращает возможность чтения или изменения данных ядра;
- `deny @{PROC}/kcore rwklx,` - предотвращает возможность чтения или модификации содержимого памяти ядра;
- `deny mount` и `deny unmount` - блокировка монтирования и размонтирования каталогов;
- `deny /sys/[^f]*/** wklx,` - запрет на запись различных системных параметров;
- `deny /sys/firmware/efi/efivars/** rwklx,` - предотвращение изменение UEFI;
- `deny /sys/kernel/security/** rwklx,` - предотвращение изменения политики безопасности;
- `deny /var/www/html/* wlx,`, `deny /var/www/html/wp-admin/** wlx,`, `deny /var/www/html/wp-includes/** wlx,`, `deny /var/www/html/wp-content/* wlx,` - запрет изменения файлов для WordPress, за исключением подкаталогов `wp-content`.
- `ptrace (trace,read) peer=docker-default,` - специальное разрешение для Docker'а, позволяющее просмотреть процессы внутри контейнера;
- `signal (receive) set=(kill,term) peer=/usr/bin/docker,` - специальное разрешает управлять контейнерами.

**3.6. Отредактируйте файл wparmor так, чтобы запретить использование каталогов в `var/www/html/wp-content` за исключением директории `uploads`. _Спарсите_ новый файл (`apparmor_parse`).**

Первым делом заходим в файл с помощью `nano`, затем запрещаем использование каталогов с помощью команды `deny /var/www/html/wp-content/* wl`, а затем разрешаем директории с помощью `deny /var/www/html/wp-content/uploads/ wlx`.
![Снимок экрана (97).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(97).png)
Теперь с помощью `apparmor_parser wparmor` сделаем последний этап.

**3.7. Повторите шаги 3.2. и 3.3. и опишите результат.**
Повторяем прошлые шаги. Скрин я опять забыла сделать.
Теперь, поскольку конфигурацией профиля `wparmor` запрещена запись и изменение объектов в каталоге `/wp-content` и `/wp-admin`, мы не можем устанавливать и активировать плагины, добавлять темы и тому подобные действия. Убеждаемся в этом при попытке установить новую тему, при попытке этого действия у нас запрашиваются FTP-данные.


### 4. Пользовательский профиль AppArmor произвольного приложения

**4.1. Выберите произвольное приложение с открытым исходным кодом (приложение может сразу поставляться в виде docker-образа или вы можете создать образ самостоятельно). Приложение должно быть подобрано таким образом, чтобы было удобно настроить политику AppArmor для него. Разверните приложение, опишите процесс выполнения развертывания.**

Мной было выбрано To Do App. Первым делом копируем репозиторий с гита.
![Снимок экрана (100).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(100).png)
Переходим в нужную директорию и создаем докер. Теперь запускаем его
![Снимок экрана (101).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(101).png)
![Снимок экрана (102).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(102).png)
Все отлично запустилось.
![Снимок экрана (103).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(103).png)

**4.2. Придумайте и опишите политику AppArmor, продемонстрируйте ее работу.**

Создаём файл apparmor и описываем его.
![Снимок экрана (104).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(104).png)
Эта политика ограничивает доступ приложения к файловой системе и ресурсам системы, обеспечивая безопасность выполнения контейнера Docker Теперь применяем политику:
![Снимок экрана (105).png](/img/user/%D0%91%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%201/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20(105).png)
